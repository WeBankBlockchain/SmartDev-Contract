# 基于区块链的食品溯源+供应链最佳实践 智能合约应用案例

> 作者： 张宇豪
>
> 学校：深圳职业技术大学

## 解决方案

基于区块链的食品溯源全供应链解决方案是利用区块链技术来追踪和记录食品从生产到消费的整个供应链过程。它能够提供透明、可信、不可篡改的信息，确保食品的安全和质量。

以下是该解决方案的主要步骤和流程：

1. 注册参与方：包括生产公司、物流公司、仓储公司、超市等各个环节的参与方，每个参与方都会被分配一个唯一的身份标识。
2. 食品生产阶段：生产公司在生产食品时，通过区块链系统记录食品的相关信息，如生产日期、生产地点、原材料来源等，并生成唯一的溯源码。这些信息被加密并存储在区块链上，确保数据的安全性。
3. 食品物流阶段：物流公司在运输食品过程中，通过区块链系统记录物流信息，包括起始地点、目的地点、运输时间等。这些信息也被加密并存储在区块链上，确保数据的可追溯性和安全性。同时，物流公司可以确认收货并签名，以保证食品的完整性和真实性。
4. 食品仓储阶段：仓储公司负责存储食品，并通过区块链系统记录食品的存储信息，如存放时间、温度等。这些信息被加密并存储在区块链上，确保数据的可追溯性和安全性。
5. 食品销售阶段：超市作为食品的最终销售环节，可以通过区块链系统查询食品的溯源信息，包括生产信息、物流信息和仓储信息等。消费者可以使用手机或扫码设备扫描食品上的溯源码，获取食品的详细信息，如生产日期、过期日期、原材料来源等，从而确保食品的安全和质量。

通过基于区块链的食品溯源全供应链解决方案，可以实现以下优势：

1. `数据的透明性`：所有参与方都可以共享和查看食品的信息，确保信息的透明和公正。
2. `数据的可信性`：区块链技术的不可篡改性和去中心化特点，确保食品信息的真实性和可信度。
3. `追溯能力`：通过溯源码和区块链技术，可以追踪食品的整个供应链历史，从原材料采购到生产、物流和销售等环节，实现全程追溯。
4. `消费者保护`：消费者可以准确获取食品的信息，包括生产地点、生产日期、原材料来源等，从而更好地保护自己的权益和健康。

基于区块链的食品溯源全供应链解决方案可以提升食品安全和质量管理水平，增加消费者的信任度，并促进整个食品行业的可持续发展。

## 智能合约

### RolesAuth合约

RolesAuth合约中定义了三个角色权限：productCompany、logisticCompany和supermaket。每个角色权限都是一个Roles.Role类型的变量，用于存储对应角色的地址集合。

合约中还定义了两个常量：IS_ROLE和NOT_ROLE。它们分别表示具有角色权限和不具有角色权限。

合约中的函数包括：

1. `addPCompanyRole`(address _userAddress)：用于添加食品生产地的权限。在添加之前，会先检查当前用户是否已经具有该角色权限，如果没有则添加。
2. `addLCompanyRole`(address _userAddress)：用于添加物流公司的权限。在添加之前，会先检查当前用户是否已经具有该角色权限，如果没有则添加。
3. `addSupermaketRole`(address _userAddress)：用于添加超市的权限。在添加之前，会先检查当前用户是否已经具有该角色权限，如果没有则添加。
4. `hasPCompanyRole`(address _userAddress)：用于检查用户是否具有食品生产地的权限。如果用户具有该权限，返回true；否则返回false。
5. `hasLCompanyRole`(address _userAddress)：用于检查用户是否具有物流公司的权限。如果用户具有该权限，返回true；否则返回false。
6. `hasSupermaketRole`(address _userAddress)：用于检查用户是否具有超市的权限。如果用户具有该权限，返回true；否则返回false。

```solidity
pragma solidity ^0.4.24;

import "./Roles.sol";

contract RolesAuth {
    
    using Roles for Roles.Role;
    
    // 创建三个不同的角色权限
    Roles.Role private productCompany;
    Roles.Role private logisticCompany;
    Roles.Role private supermaket;
    
    
    // 定义两个常量, 我是用constant可以减少gas消耗 
    bool constant internal IS_ROLE = true;
    bool constant internal NOT_ROLE = false;
    
    // 添加食品生产地的权限
    function addPCompanyRole(address _userAddress) {
        require(productCompany.has(_userAddress) == NOT_ROLE,"当前用户已经存在角色权限");
        productCompany.add(_userAddress);
    }
    
    
    // 添加物流公司的权限
    function addLCompanyRole(address _userAddress) {
        require(logisticCompany.has(_userAddress) == NOT_ROLE,"当前用户已经存在角色权限");
        logisticCompany.add(_userAddress);
    }

    // 添加超市的权限
    function addSupermaketRole(address _userAddress) {
        require(supermaket.has(_userAddress) == NOT_ROLE,"当前用户已经存在角色权限");
        supermaket.add(_userAddress);
    }
    
    function hasPCompanyRole(address _userAddress) public returns(bool){
        return productCompany.has(_userAddress);
    }
     
    function hasLCompanyRole(address _userAddress) public returns(bool){
        return logisticCompany.has(_userAddress);
    }
     
    function hasSupermaketRole(address _userAddress) public returns(bool){
        return supermaket.has(_userAddress);
    }
    
}
```





### EventService合约

EventService合约中定义了五个事件：

1. `Registered`：注册事件，当一个用户注册时触发该事件。事件参数包括用户的地址（_userAddress）和用户名（_userName）。
2. `AddFood`：添加食品事件，当一个食品被添加时触发该事件。事件参数包括食品公司的地址（_companyAddress）和食品的ID（_foodId）。
3. `MakeReport`：检查食品生成报告事件，当对食品进行检查并生成报告时触发该事件。事件参数包括监管机构的地址（_regulatorAddress）和报告的ID（_reportId）。
4. `AddLogistic`：添加物流事件，当一个物流公司接收到一个订单时触发该事件。事件参数包括物流公司的地址（_logisticCompanyAddr）和订单的ID（_orderId）。
5. `Receipt`：超市签收事件，当一个超市签收一个订单时触发该事件。事件参数包括超市的地址（_supermaketAddress）和订单的ID（_orderId）。

这些事件可以在合约中被触发，并且在区块链上被记录下来。其他合约或应用程序可以监听这些事件，并根据需要做出相应的逻辑处理。事件的使用可以提供更多的可追溯性和可观察性，增强合约的交互性和透明性。

```solidity
pragma solidity ^0.4.25;

// 所有事件
contract EventService {
    
    // 注册事件 
    event Registered(address indexed _userAddress,string _userName);
    
    // 添加食品
    event AddFood(address indexed _companyAddress,uint256 indexed _foodId);
    
    // 检查食品生成报告
    event MakeReport(address indexed _regulatorAddress,uint256 indexed _reportId);
    
    // 添加物流
    event AddLogistic(address indexed _logisticCompanyAddr,uint256 indexed _orderId);
    
    // 超市签收
    event Receipt(address indexed _supermaketAddress,uint256 indexed _orderId);
    
}
```



### RegulatoryAgency合约

RegulatoryAgency是监管机构合约，用于记录和管理食品的健康报告和监管机构的信息。

合约中引入了一个名为EventService.sol的合约，用于定义和触发各种事件。

合约中定义了两个结构体：Report和Regulator。

1. `Report`结构体：用于记录食品的健康报告。它包括报告ID（reportId）、报告名称（reportName）、健康等级（healthLevel）和食品名称（foodName）。
2. `Regulator`结构体：用于表示监管机构的信息。它包括监管机构的地址（regulatorAddress）、监管机构的名称（regulatorName）和监管机构所有报告的列表（reportList）。

合约中定义了一个枚举类型Levels，用于表示食品的健康等级。

合约中还定义了两个映射类型的变量：regulatorMap和reportMap。

1. `regulatorMap`：用于将监管机构的地址映射到对应的Regulator结构体。
2. `reportMap`：用于将食品ID映射到对应的Report结构体。

合约中的函数包括：

1. `registerRegulator`(string memory _regulatorName)：用于注册监管机构。在注册过程中，将监管机构的地址、名称存储到regulatorMap中，并触发Registered事件。
2. `queryRegulator`(address _regulatorAddress)：用于查询监管机构的信息。根据监管机构的地址从regulatorMap中获取对应的Regulator结构体。

合约继承了EventService合约，可以使用其中定义的事件。

这个合约的主要功能是注册监管机构、记录食品的健康报告和查询监管机构的信息。它通过使用映射和结构体来存储和管理数据，并使用事件来提供可观察性和可追溯性。

```solidity
pragma solidity ^0.4.25;
pragma experimental ABIEncoderV2;

import "./EventService.sol";

contract RegulatoryAgency is EventService{
    
    // 监管报告结构，记录食物的健康报告
    struct Report {
        uint256 reportId;       // 报告ID
        string  reportName;     // 报告名字
        Levels  healthLevel;    // 健康等级
        string  foodName;       // 食品名称
    }
    
    // 监管机构结构体
    struct Regulator {
        address regulatorAddress;   // 监管机构地址
        string  regulatorName;      // 监管机构名称
        Report[] reportList;        // 监管机构所有报告
    }
    
    // 食品健康等级
    enum  Levels {ONE_LEVEL,TWO_LEVEL,THREE_LEVEL,FOUR_LEVEL,FIVE_LEVEL}
    
    // 地址映射监管机构
    mapping(address => Regulator) public regulatorMap;
    // 食品ID映射报告
    mapping(uint256 => Report) public reportMap;
    
    // 注册监管机构
    function registerRegulator(string memory _regulatorName) public {
        Regulator storage _regulator = regulatorMap[msg.sender];
        _regulator.regulatorAddress = msg.sender;
        _regulator.regulatorName = _regulatorName;
        emit Registered(msg.sender,_regulatorName);
    }
    
    
    // 查询监管机构
    function queryRegulator(address _regulatorAddress) public view returns(Regulator memory) {
        Regulator memory regulator = regulatorMap[_regulatorAddress];
        return regulator;
    }
    
}

```



### FoodTraceability合约

FoodTraceability合约是一个食品溯源系统，用于记录和追踪食品的生产、物流和销售信息。该合约包括了以下几个结构体：

1. `Food`（食品）：记录食品的相关信息，包括食品id、食品名称、生产日期、过期日期、溯源码、当前食物状态和食品溯源追溯历史等。
2. `Logistics`（物流）：记录物流信息，包括物流id、物流公司地址、食品id、发货地点、收货地点、运输日期和是否已确认收货等。
3. `ProductionCompany`（生产公司）：记录生产公司的信息，包括公司id、公司名称、公司地址和企业生产的食品列表等。
4. `LogisticCompany`（物流公司）：记录物流公司的信息，包括公司id、公司名称、公司地址和物流订单id列表等。
5. `Supermarket`（超市）：记录超市的信息，包括超市id、超市名称、超市地址和超市出售的食物列表等。

该合约提供了以下功能：

1. 注册生产公司、物流公司和超市。
2. 添加新的食品信息，包括食品名称、生产日期、过期日期等。
3. 监管部门确认食品是否合格，并生成食品报告。
4. 添加食品的物流信息，包括物流公司地址、发货地点、收货地点等。
5. 超市签收物流订单，并确认是否拒收。
6. 超市出售食品。
7. 查询物流公司的所有订单详细信息。
8. 查询生产公司、物流公司和超市的详细信息。
9. 查询食品的溯源信息，包括溯源码和溯源历史。
10. 查询食品的报告。
11. 生成食品的溯源码。

通过上述功能，该智能合约可以实现对食品的全程追溯，确保食品的安全和质量。

>  LibCryptoHash合约是工具类 （使用hash对应食品的唯一标识）
>
> TypeConvertUtil合约是工具类

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.25;
pragma experimental ABIEncoderV2;


import "./RegulatoryAgency.sol";
import "./LibCryptoHash.sol";
import "./TypeConvertUtil.sol";
import "./RolesAuth.sol";

// 食品结构体，记录食品信息
contract FoodTraceability is RegulatoryAgency {
    
    RolesAuth rolesAuth;
    
    using LibCryptoHash for *;
    using TypeConvertUtil for *;
    
    struct Food {
        uint256 foodId;               // 食品id
        string  foodName;             // 食品名称
        uint256 foodProductionDate;   // 生产日期
        uint256 foodExpirationDate;   // 过期日期
        bytes32 foodTraceabilityCode; // 溯源码
        Status  foodStatus;           // 当前食物状态
        address[] foodTraceabilityHistory; // 食品溯源追溯
    }
    
    // 物流结构体，记录物流信息
    struct Logistics {
        uint256 logisticsId;            // 物流id
        address logisticsAddress;       // 物流公司地址
        uint256 foodId;                 // 食品id
        address logisticsFrom;          // 发货地点   生产厂家的地址
        address logisticsTo;            // 收货地点   收获地址为超市
        uint256 logisticsTransportDate; // 运输日期
        bool    verfalid;               // 确认收货或者拒绝收货
    }
    
    // 生产公司结构体，记录生产公司信息
    struct ProductionCompany {
        uint256 companyId;          // 生产公司id
        string  companyName;        // 生产公司名称
        address companyAddress;     // 生产公司地址
        Food[]  companyfoods;       // 企业生产的食品
    }
    // 物流公司结构体，记录物流公司信息
    struct LogisticCompany {
        uint256 companyId;          // 物流公司id
        string  companyName;        // 物流公司名称
        address companyAddress;     // 物流公司地址
        uint256[] orders;           // 物流订单id
    }
    
    // 超市结构体，记录超市信息
    struct Supermarket {
        uint256 supermarketId;       // 超市id
        string  supermarketName;     // 超市名称
        address supermarketLocation; // 超市地址
        Food[]  foodList;            // 超市出售的食物
    }
    
    
    // 分别定义: 0生产中，1运输中，2已收货，3出售中
    enum Status {PRODUCTION,INTRANSIT,RECEIPT,UNDERSALE}
    
    // 所有的ID
    uint256 private foodCount;
    uint256 private logisticsCount;
    uint256 private productionCompanyCount;
    uint256 private supermarketCount;
    uint256 private logisticCompanyCount;
    uint256 public  reportCount;
    
    Levels L3 = Levels.TWO_LEVEL;
    Levels L4 = Levels.THREE_LEVEL;
    Levels L5 = Levels.FOUR_LEVEL;
    
    
    // 食物集合
    Food[] private foodList;
    // 物流订单信息
    Logistics[] private logisticsList;
    // 生产公司集合
    ProductionCompany[] private productionCompanyList;
    // 超市集合
    Supermarket[] private supermarketList;
    // 物流公司集合
    LogisticCompany[] private LogisticCompanyList;
    
    
    // 定义一个 mapping 存储食品信息
    mapping(uint256 => Food) private foodMap;
    // 定义一个 mapping 存储食品报告信息
    mapping(uint256 => Report) private foodIdToReportMap;
    // 定义一个 mapping 存储食物Id对应的报告 
    mapping(bytes32 => address[]) private foodTraceabilityHistoryMap;
    // 定义一个 mapping 存储物流信息
    mapping(uint256 => Logistics) private logisticsMap;
    // 定义一个 mapping 存储生产公司信息
    mapping(address => ProductionCompany) private productionCompaniesMap;
    // 定义一个 mapping 存储物流公司信息
    mapping(address => LogisticCompany) private logisticCompanyMap;
    // 定义一个 mapping 存储超市信息
    mapping(address => Supermarket) private supermarketsMap;

    
    
    // 初始化一个食品监管机构
    constructor(){
        registerRegulator("食品安全监管机构");
        rolesAuth = new RolesAuth();
    }
    
    // 修饰符函数
    modifier AuthPCompany {
        require(rolesAuth.hasPCompanyRole(msg.sender),"没有权限");
        _;
    }
    // 修饰符函数    
    modifier AuthLCompany {
        require(rolesAuth.hasLCompanyRole(msg.sender),"没有权限");
        _;
    }
    // 修饰符函数    
    modifier AuthSupermaket {
        require(rolesAuth.hasSupermaketRole(msg.sender),"没有权限");
        _;
    }
    
    // 定义一个函数用于注册生产公司
    function registerCompany(string memory _companyName) public {
        require(productionCompaniesMap[msg.sender].companyId == 0,"当前企业已经注册");
        productionCompanyCount++;
        uint256 _companyId = productionCompanyCount;
        ProductionCompany storage _company = productionCompaniesMap[msg.sender];
        _company.companyId = _companyId;
        _company.companyName = _companyName;
        _company.companyAddress = msg.sender;
        productionCompanyList.push(_company);
        // 添加默认角色权限
        rolesAuth.addPCompanyRole(msg.sender);
        emit Registered(msg.sender,_companyName);
    }
    
    
    // 定义一个函数用于注册物流公司
    function registerLogisticsCompany(string memory _companyName) public {
        logisticCompanyCount++;
        uint256 logisticId = logisticCompanyCount;
        LogisticCompany storage _company = logisticCompanyMap[msg.sender];
        _company.companyId = logisticId;
        _company.companyName = _companyName;
        _company.companyAddress = msg.sender;
        LogisticCompanyList.push(_company);
        // 添加默认角色权限
        rolesAuth.addLCompanyRole(msg.sender);
        emit Registered(msg.sender,_companyName);
    }
    
    
    // 定义一个函数用于注册超市
    function registerSupermarket(string memory _supermarketName) public {
        require(supermarketsMap[msg.sender].supermarketId == 0,"当前的超市已经注册");
        supermarketCount++;
        uint256 supermarketId = supermarketCount;
        Supermarket storage _supermarket = supermarketsMap[msg.sender];
        _supermarket.supermarketId = supermarketId;
        _supermarket.supermarketName = _supermarketName;
        _supermarket.supermarketLocation = msg.sender;
        supermarketList.push(_supermarket);
        // 添加角色默认权限
        rolesAuth.addSupermaketRole(msg.sender);
        emit Registered(msg.sender,_supermarketName);
    }

    /*
     * @dev 定义一个函数用于添加新的食品信息
     */ 
    function productFood(address _companyAddress,string memory _foodName) public AuthPCompany {
        foodCount++;
        uint256 foodId = foodCount;
        bytes32 result = generateTraceabilityCode(foodId);
        Food storage _food = foodMap[foodId];
        _food.foodId = foodId;
        _food.foodName = _foodName;
        _food.foodProductionDate = block.timestamp;
        _food.foodExpirationDate = block.timestamp + 6 * 1 weeks;
        _food.foodTraceabilityCode = result;
        _food.foodStatus = Status.PRODUCTION;
        _food.foodTraceabilityHistory.push(_companyAddress);
        foodList.push(_food);
        
        ProductionCompany storage product = productionCompaniesMap[_companyAddress];
        product.companyfoods.push(_food);
        foodTraceabilityHistoryMap[result].push(_companyAddress);
        emit AddFood(_companyAddress,foodId);
    }
    
    
    // 监管部门需要确认食品是否合格 3级以下不给出售 // 只有监管部门能操作
    function healthReport(uint256 _foodId,string memory _reportName,Levels _reportLevel) public returns(int){
        reportCount++;
        uint256 reportId = reportCount;
        Regulator storage _regulator = regulatorMap[msg.sender];
        Report storage _report = reportMap[reportId];
        Food storage _food = foodMap[_foodId]; 
        if (_food.foodId == _foodId){
            _report.reportId = reportId;
            _report.reportName = _reportName;                                                         
            _report.healthLevel = _reportLevel;
            _report.foodName = _food.foodName;
            _regulator.reportList.push(_report);
            foodIdToReportMap[_foodId] = _report;
            emit MakeReport(msg.sender,reportId);
            return 0;
        }
        return -1;
        
    }

    // 定义一个函数用于食品的物流信息
    function addLogistics(address _logisticsAddress,uint256 foodId, address _from, address _to) public AuthLCompany{
        Food storage _food = foodMap[foodId];
        Report memory report = queryFoodReport(foodId);
        // 判断食品是否状态正常 食品是否合格
	    require(_food.foodStatus == Status.PRODUCTION,"当前的食品状态异常");
	    require(report.healthLevel == L3 || report.healthLevel == L4 || report.healthLevel == L5,"当前的食品不合格");
	    logisticsCount++;
	    uint256 _logisticsId = logisticsCount;
	    // 新建物流订单
	    Logistics storage _logistics = logisticsMap[_logisticsId];
	    _logistics.logisticsId = _logisticsId;
	    _logistics.foodId = foodId;
	    _logistics.logisticsAddress = _logisticsAddress;
	    _logistics.logisticsFrom = _from;
	    _logistics.logisticsTo = _to;
	    _logistics.logisticsTransportDate = block.timestamp;
	    _logistics.verfalid = false;
	    
	    // 修改食品的状态
	    _food.foodStatus = Status.INTRANSIT;
	    _food.foodTraceabilityHistory.push(_logisticsAddress);
	    // 添加物流信息
	    logisticCompanyMap[_logisticsAddress].orders.push(_logisticsId);
	    logisticsList.push(_logistics);
	    
	    emit AddLogistic(_logisticsAddress,_logisticsId);
    }
    
    // 超市收货签收
    // 超市收获需要确认订单的Id，是否拒收等
    function signature(uint256 _logisticsId,bool _isApporve) public AuthSupermaket returns(int){
        // 确认签收
        if (_isApporve){
            Logistics storage _logisticOrder = logisticsMap[_logisticsId];
            Supermarket storage _supermarket = supermarketsMap[msg.sender];
            Food storage _food = foodMap[_logisticOrder.foodId];
            require(_supermarket.supermarketId != 0,"当前超市未注册");
            require(_logisticOrder.verfalid == false,"当前订单已签收，无需再签收");
            require(_food.foodStatus == Status.INTRANSIT,"当前物流异常");
            if (_logisticOrder.logisticsTo == msg.sender){
                _food.foodStatus = Status.RECEIPT;
                _food.foodTraceabilityHistory.push(msg.sender);
                _logisticOrder.verfalid = true;
                emit Receipt(msg.sender,_logisticsId);
            }
            // 这么返回是用来后端接收的
            return 0;
        }
        return -1;
    }
    
    
    // 超市出售当前的食物
    function sellFood(uint256 _foodId) public AuthSupermaket {
        Supermarket storage _supermarket = supermarketsMap[msg.sender];
        Food storage _food = foodMap[_foodId];
        require(_food.foodStatus == Status.RECEIPT,"当前的食品还未签收");
        _food.foodStatus = Status.UNDERSALE;
        _supermarket.foodList.push(foodMap[_foodId]);
    }
    
    
    // 查询物流公司的所有订单详细
    function queryLogisticCompanyOrdersInfo(address _LogisticsAddress) public returns(Logistics[] memory){
        LogisticCompany memory _logisticCompany = logisticCompanyMap[_LogisticsAddress];
        Logistics[] memory logisticsList = new Logistics[](_logisticCompany.orders.length);
        for (uint i = 0;i < _logisticCompany.orders.length; ++i){
            logisticsList[i] = logisticsMap[_logisticCompany.orders[i]];
        }
        return logisticsList;
    }
    
	
	// 查询生产公司的详细信息
    function queryProductionCompanyInfo(address _companyAddress) public returns(ProductionCompany memory){
        return productionCompaniesMap[_companyAddress];
    }
    
    // 查询物流公司的详细信息
    function queryLogisticCompanyInfo(address _companyAddress) public returns(LogisticCompany memory){
        return logisticCompanyMap[_companyAddress];
    }
    
    // 定义一个函数用于记录食品的流通环节信息
    function queryLogisticsInfo(uint256 _logisticsId) public returns(Logistics memory) {
        return logisticsMap[_logisticsId];
    }
    
    
        // 查询食品的报告
    function queryFoodReport(uint256 _foodId) public view returns(Report memory){
        return foodIdToReportMap[_foodId];
    }
    
    // 定义一个函数用于生成食品的溯源码
    function generateTraceabilityCode(uint256 foodId) public returns(bytes32) {
        return LibCryptoHash.getSha256(TypeConvertUtil.uintToString(foodId));
    }
    
    // 定义一个函数用于查询食品的溯源信息
    function queryFoodTraceabilityInfo(uint256 _foodId) public returns(address[] memory){
        return foodMap[_foodId].foodTraceabilityHistory;
    }
    
    // 查询食品的详细信息
    function queryFoodInfo(uint256 _foodId) public view returns(Food memory){
        return foodMap[_foodId];
    }
    
    // 查询食品的溯源码
    function queryFoodTraceabilityCode(uint256 _foodId) public view returns(bytes32){
        return foodMap[_foodId].foodTraceabilityCode;
    }
    
    // 查询超市的详细信息
    function querySupermarketInfo(address _supermarketAddress) public returns(Supermarket memory){
        return supermarketsMap[_supermarketAddress];
    }
}

```

