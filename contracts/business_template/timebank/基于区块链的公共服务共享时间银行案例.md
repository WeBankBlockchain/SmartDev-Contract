

# 基于区块链的公共服务共享时间银行案例

## 基本介绍

基于公共服务的时间银行是指以公共服务为基础，通过时间银行的方式来实现服务的交换和时间的储蓄。公共服务通常是指由政府或社会组织提供的、面向公众的服务，如环保、义工、文化活动等。

我们的时间银行的业务通常包括以下几个方面：

1. `服务交换`：时间银行的核心业务是服务交换，即会员之间相互提供各种服务，如家务、修理、照顾孩子、教授技能等。会员可以通过时间银行平台查找需要的服务，并与服务提供者联系。
2. `时间储蓄`：会员可以将自己的时间存入时间银行，以便在未来需要服务时使用。会员需要记录服务的时间，并在时间银行平台上提交服务记录。
3. `社区项目`：时间银行可以为社区提供各种项目，如环保、义工、文化活动等。会员可以参与社区项目，以获得相应的时间储蓄。
4. `社交活动`：时间银行可以举办各种社交活动，如聚会、旅行、运动等，以促进会员之间的交流和互动。

基于公共服务的时间银行可以促进公共服务的提供和社区建设，同时也可以提高会员的服务意识和社会责任感。

## 用例功能说明

![image-20231024152209081](https://blog-1304715799.cos.ap-nanjing.myqcloud.com/imgs/202310241522120.png)



## 智能合约

### ServiceInfo合约


`ServiceInfo`合约是一个基于区块链的时间服务合约，主要用于提供时间服务的信息管理和服务交换功能。

合约中包括以下几个主要部分：

1. ServiceInfo结构体：用于存储时间服务的基本信息，包括服务名称、内容、所有者、服务时间和状态等。其中，服务状态包括AVAILABLE（可用）、USING（使用中）、CONSUMED（已消费）和ERROR（异常）等状态。
2. InitTimeService事件：用于初始化时间服务的信息内容，并将服务名称和当前时间戳记录在区块链上。
3. getServiceInfo函数：用于查询当前的时间服务信息，返回服务名称、内容、所有者、服务时间和状态等信息。
4. exchangeService函数：用于进行服务交换，即将服务所有者从当前用户地址更改为目标用户地址。需要满足当前服务状态不为ERROR（异常）且服务所有者为当前用户地址。

```solidity
pragma solidity ^0.6.10;

/**
 * @title 服务信息
 * @notice 提供时间服务的信息
 */
contract ServiceInfo {
    
    // 提供的
    string _name;

    // 服务内容
    string _content;

    // 服务所属人地址
    address _owner;

    // 服务时间
    uint256 _timestamp;

    // 服务状态
    TimeStatus _status;

    // 当前服务状态
    enum TimeStatus {
        AVAILABLE,
        USING,
        CONSUMED,
        ERROR
    }

    // 初始化时间服务的事件
    event InitTimeService(string indexed,uint256 indexed);

    /**
     * 初始化时间服务的信息内容
     * @param name 时间服务名称
     * @param content 时间服务的内容
     * @param owner 时间服务的所有者
     * @param timestamp 提供的时间
     */
    constructor(string memory name,string memory content,address owner,uint256 timestamp) public {
        _name = name;
        _content = content;
        _owner = owner;
        _timestamp = timestamp;
        _status = TimeStatus.AVAILABLE;

        emit InitTimeService(name,block.timestamp);
    }

    /**
     * 查询当前的时间服务信息
     * @return _name 时间服务名称
     * @return _content 时间服务内容
     * @return _owner 时间服务所有者
     * @return _timestamp 服务时间
     * @return _status 服务状态
     */
    function getServiceInfo() public view returns(
        string memory,
        string memory,
        address,
        uint256,
        TimeStatus) 
    {
        return (_name,_content,_owner,_timestamp,_status);
    }


    /**
     * 服务交换
     * @param _from 当前服务提供的用户地址
     * @param _to  交换后所属的用户地址
     */
    function exchangeService(address _from,address _to) public  {
        require(_status != TimeStatus.ERROR,"当前状态异常,无法交换服务");
        require(_owner == _from,"当前不是你提供的时间服务");
        _status = TimeStatus.USING;
        _owner = _to;        
    }

    /**
     * 时间消费
     */
    function timeUsage() public {
        require(_status != TimeStatus.ERROR,"当前状态异常,无法交换服务");
        _status = TimeStatus.CONSUMED;
    }



}
```

### TimeBankManager合约

`TimeBankManager`的合约是一个时间银行的主合约，它用于管理时间服务和交换记录。合约中包含以下重要功能：

1. 用户注册：用户可以通过调用`register`函数进行注册，提供用户名和用户地址。

2. 时间存储：用户可以通过调用`timeStore`函数将时间服务信息存储到时间银行中，包括服务名称、内容、所有者和服务时间。

3. 查询时间服务信息：用户可以通过调用`getTimeService`函数查询特定时间服务的详细信息，包括名称、内容、所有者、服务时间和状态。

4. 查询用户的所有时间服务信息：用户可以通过调用`getUserAllService`函数查询特定用户的所有时间服务信息，包括名称、内容和时间。

5. 服务交换：用户可以通过调用`tradeForService`函数进行时间服务的交换。用户可以指定交换的两个时间服务ID，合约会自动进行服务交换，并更新用户的时间服务列表和交换记录。

6. 查询服务交换记录：用户可以通过调用`getExchangeRecord`函数查询特定交换记录的详细信息，包括记录ID、发起交换的用户地址、被交换的用户地址、发起交换的用户时间服务ID、被交换的用户时间服务ID和交换时间。

7. 时间消费：用户可以通过调用`timeUsage`函数消费时间服务。该函数会更新时间服务的状态。

8. 判断时间服务ID是否存在：用户可以通过调用`checkServiceExit`函数判断特定时间服务ID是否存在。

```solidity
pragma solidity ^0.6.10;
pragma experimental ABIEncoderV2;

/**
 * @title 时间银行主合约 
 * @notice 
 */

import "./ServiceInfo.sol";

contract TimeBankManager {

    // 时间银行管理地址
    address _timeBank;

    uint256 serviceCount;
    uint256 recordCount;

    // 用户结构体
    struct User {
        string name;
        address userAddress;
        uint256[] timeservices;
        uint256[] exchanges;

    }

    // 交换记录
    struct ExchangeRecord {
        uint256 recordId;
        address from;
        address to;
        address fromServiceAddress;
        address toServiceAddress;
        uint256 time;
    }

    // 所有时间服务的地址
    address[] services;

    // 服务的ID映射时间服务的合约地址
    mapping (uint256=>address) serviceIdToAddress;

    // 用户地址映射用户信息
    mapping (address=>User) userMap;

    // 记录ID映射记录信息
    mapping (uint256=>ExchangeRecord) recordMap;

    
    // 用户注册事件
    event Registered(address indexed,uint256 indexed);
    // 时间服务交换
    event TradeForService(address indexed,address indexed,uint256 indexed);


    constructor() public {
        _timeBank = msg.sender;
    }


    /**
     * 用户注册
     * @param _username 用户名称
     * @param _userAddress  用户地址
     */
    function register(
        string memory _username,
        address _userAddress
    ) public {
        require(userMap[_userAddress].userAddress == address(0),"This user already register");
        User memory _user = User(_username,_userAddress,new uint256[](0),new uint256[](0));
        userMap[_userAddress] = _user; 
        emit Registered(_userAddress,block.timestamp);
    }


    /**
     * 时间存储
     * @param name 时间服务名称
     * @param content 时间服务内容
     * @param owner 时间服务所属者
     * @param time 时间默认是1 * 1day时间
     */
    function timeStore(
        string memory name,
        string memory content,
        address owner,uint8 time
    ) public {
        serviceCount++;
        uint256 timestamp = time * 1 days;
        // 用户添加服务信息时间进行时间存储
        User storage _user = userMap[owner];
        ServiceInfo serviceInfo = new ServiceInfo(name,content,owner,timestamp);
        
        _user.timeservices.push(serviceCount);
        services.push(address(serviceInfo));

        serviceIdToAddress[serviceCount] = address(serviceInfo);
        
    }

    /**
     * 查询当前的时间服务信息
     * @return _name 时间服务名称
     * @return _content 时间服务内容
     * @return _owner 时间服务所有者
     * @return _timestamp 服务时间
     * @return _status 服务状态
     */
    function getTimeService(uint256 _id) public view returns(
        string memory,
        string memory,
        address,
        uint256,
        ServiceInfo.TimeStatus) 
    {
        return ServiceInfo(serviceIdToAddress[_id]).getServiceInfo();
    }


    /**
     * 查询用户的所有时间服务信息
     * @param _userAddress 用户的地址
     * @return nameList 所有时间服务名称
     * @return contentList 所有时间服务内容
     * @return timeList 所有时间
     */
    function getUserAllService(address _userAddress) public view returns(
        string[] memory,
        string[] memory,
        uint256[] memory
        ){
        require(_userAddress != address(0),"当前的用户地址不能为空");
        uint256[] memory serviceArr = userMap[_userAddress].timeservices;

        address[] memory serviceList = new address[](serviceArr.length);

        string[] memory nameList = new string[](serviceList.length);
        string[] memory contentList = new string[](serviceList.length);
        uint256[] memory timeList = new uint256[](serviceList.length);

        for (uint256 i = 0; i < serviceArr.length; i++) {
            serviceList[i] = serviceIdToAddress[serviceArr[i]];
        }
        for (uint256 j = 0; j < serviceList.length; j++) {
            (
            string memory name,
            string memory content,
            address owner,
            uint256 time,
            ServiceInfo.TimeStatus status) =  ServiceInfo(serviceList[j]).getServiceInfo();
            nameList[j] = name;
            contentList[j] = content;
            timeList[j] = time;
        }
        return (nameList,contentList,timeList);

    }


    /**
     * 服务交换
     * @param _ownerAddress 时间服务所属人地址
     * @param _toAddress  交换的用户地址
     * @param _fromServiceId 所属的时间服务ID
     * @param _toServiceId  交换的用户的时间服务ID
     */
    function tradeForService(
        address _ownerAddress,
        address _toAddress,
        uint256 _fromServiceId,
        uint256 _toServiceId
    ) public  {
        if (userMap[_ownerAddress].userAddress == address(0) || userMap[_toAddress].userAddress == address(0)) {
            revert("当前用户未注册");
        }
        // 初始化记录值
        recordCount++;
        ExchangeRecord storage _ExchangeRecord = recordMap[recordCount];
        _ExchangeRecord.from = _ownerAddress;
        _ExchangeRecord.to = _toAddress;
        _ExchangeRecord.fromServiceAddress = serviceIdToAddress[_fromServiceId];
        _ExchangeRecord.toServiceAddress = serviceIdToAddress[_toServiceId];

        ServiceInfo(serviceIdToAddress[_fromServiceId]).exchangeService(_ownerAddress,_toAddress);
        ServiceInfo(serviceIdToAddress[_toServiceId]).exchangeService(_toAddress, _ownerAddress);

        userMap[_ownerAddress].exchanges.push(recordCount);
        userMap[_toAddress].exchanges.push(recordCount);

        uint256[] memory oservicesList = userMap[_ownerAddress].timeservices;
        uint256[] memory tservicesList = userMap[_toAddress].timeservices;

        for (uint256 i = 0; i < oservicesList.length;i++) {
            if (oservicesList[i] == _fromServiceId) {
                userMap[_ownerAddress].timeservices[i] = _toServiceId;
            }
        }
        for (uint256 j = 0; j < tservicesList.length;j++) {
            if (tservicesList[j] == _toServiceId) {
                userMap[_toAddress].timeservices[j] = _toServiceId;
            }
        }
        emit TradeForService(_ownerAddress,_toAddress,block.timestamp);
    }


    /**
     * 查询服务交换记录
     * @param _recordId 记录ID
     * @return recordId 记录ID
     * @return from 发起交换的用户地址
     * @return to 被交换的用户地址
     * @return fromServiceAddress 发起交换的用户时间服务ID
     * @return toServiceAddress 被交换的用户时间服务ID
     * @return time 交换时间
     */
    function getExchangeRecord(uint256 _recordId) public view returns(
        uint256,
        address,
        address,
        address,
        address,
        uint256
    ) {
        return (recordMap[_recordId].recordId,
                recordMap[_recordId].from,
                recordMap[_recordId].to,
                recordMap[_recordId].fromServiceAddress,
                recordMap[_recordId].toServiceAddress,
                recordMap[_recordId].time
        );
    }

    /**
     * 时间消费
     * @param _userAddress 用户地址
     * @param _serviceId 用户的时间服务ID
     */
    function timeUsage(address _userAddress,uint256 _serviceId) public {
        require(userMap[_userAddress].userAddress != address(0),"当前用户未注册");
        ServiceInfo(serviceIdToAddress[_serviceId]).timeUsage();
    }

    /**
     * 判断当前的时间服务ID是否存在
     * @param _id 时间服务ID
     */
    function checkServiceExit(uint256 _id) public view returns(bool) {
        for (uint i = 0; i < serviceCount; i++) {
            if (_id == i) {
                return true;
            }
        }
        return false;
    }
    
}
```

